{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "6a1f1552-476b-4912-8f3c-e4cc2a6fceba",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Configuration initiale de la lettre N bruitée: [1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1]\n",
      "L'état prend la valeur --> [1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1]\n",
      "L'état prend la valeur --> [1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1]\n",
      "Configuration finale de N bruitée: [1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1] ce qui correspond à la 14 ème lettre de l'alphabet\n"
     ]
    }
   ],
   "source": [
    "# Fonction d'activation : Retourne 0 si la somme est négative, sinon 1\n",
    "activation_fonction = lambda somme: 0 if somme < 0 else 1\n",
    "\n",
    "# Paramètres du réseau de Hopfield\n",
    "taille_grille = 5  # Taille du réseau (5x5 = 25 cellules)\n",
    "nombre_cellules = taille_grille * taille_grille  # Nombre total de cellules\n",
    "\n",
    "taux_apprentissage = 0.2  # Paramètre d'apprentissage\n",
    "\n",
    "# Initialisation des états des cellules (chaque cellule est initialisée à 0)\n",
    "etats_cellules = [0 for _ in range(nombre_cellules)]\n",
    "\n",
    "# Seuils d'activation des cellules (chaque cellule a un seuil, initialisé à 0.0)\n",
    "seuils_cellules = [0.0 for _ in range(nombre_cellules)]\n",
    "\n",
    "# Poids des connexions entre les cellules (chaque connexion est initialisée à 0.5)\n",
    "poids_connexions = [[0.5 for _ in range(nombre_cellules)] for _ in range(nombre_cellules)]\n",
    "\n",
    "# Élimination des boucles (les connexions d'une cellule à elle-même sont mises à 0)\n",
    "for i in range(nombre_cellules):\n",
    "    poids_connexions[i][i] = 0\n",
    "\n",
    "# Exemple de lettre bruitée à reconnaître (ici une lettre \"N\" bruitée)\n",
    "lettre_bruitee = [\n",
    "    1, 0, 1, 0, 1,\n",
    "    1, 1, 0, 0, 1,\n",
    "    0, 0, 1, 0, 1,\n",
    "    1, 0, 0, 1, 1,\n",
    "    1, 0, 0, 0, 1\n",
    "]\n",
    "\n",
    "# Alphabet stocké : représentation binaire des lettres de l'alphabet (5x5 pour chaque lettre)\n",
    "alphabet_binaire = \\\n",
    "[ [ 0, 1,  1,  1,  0,  # { A }\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  1,  1,  1,  1,\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 0, 1] ,\n",
    "   [ 1,  1,  1,  1,  0,  # { B }\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  1,  1,  1,  0,\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  1,  1,  1,  0 ],\n",
    "   [ 0, 1,  1,  1,  1,   # { C }\n",
    "     1,  0, 0, 0, 0,\n",
    "     1,  0, 0, 0, 0,\n",
    "     1,  0, 0, 0, 0,\n",
    "     0, 1,  1,  1,  1 ],\n",
    "   [ 1,  1,  1,  1,  0,  # { D }\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  1,  1,  1,  0 ],\n",
    "   [ 1,  1,  1,  1,  1,   # { E }\n",
    "     1,  0, 0, 0, 0,\n",
    "     1,  1,  1,  0, 0,\n",
    "     1,  0, 0, 0, 0,\n",
    "     1,  1,  1,  1,  1 ],\n",
    "   [ 1,  1,  1,  1,  1,   # { F }\n",
    "     1,  0, 0, 0, 0,\n",
    "     1,  1,  1,  0, 0,\n",
    "     1,  0, 0, 0, 0,\n",
    "     1,  0, 0, 0, 0 ],\n",
    "   [ 1,  1,  1,  1,  1,   # { G }\n",
    "     1,  0, 0, 0, 0,\n",
    "     1,  0, 0, 0, 0,\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  1,  1,  1,  1 ],\n",
    "   [ 1,  0, 0, 0, 1,   # { H }\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  1,  1,  1,  1,\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 0, 1 ],\n",
    "   [ 0, 0, 1,  0, 0,  # { I }\n",
    "     0, 0, 1,  0, 0,\n",
    "     0, 0, 1,  0, 0,\n",
    "     0, 0, 1,  0, 0,\n",
    "     0, 0, 1,  0, 0 ],\n",
    "   [ 0, 0, 1,  1,  1,   # { J }\n",
    "     0, 0, 0, 1,  0,\n",
    "     0, 0, 0, 1,  0,\n",
    "     0, 0, 0, 1,  0,\n",
    "     1,  1,  1,  1,  0 ],\n",
    "   [ 1,  0, 0, 0, 1,   # { K }\n",
    "     1,  0, 0, 1,  0,\n",
    "     1,  1,  1,  0, 0,\n",
    "     1,  0, 0, 1,  0,\n",
    "     1,  0, 0, 0, 1 ],\n",
    "   [ 1,  0, 0, 0, 0,  # { L }\n",
    "     1,  0, 0, 0, 0,\n",
    "     1,  0, 0, 0, 0,\n",
    "     1,  0, 0, 0, 0,\n",
    "     1,  1,  1,  1,  1 ],\n",
    "   [ 1,  1,  0, 1,  1,   # { M }\n",
    "     1,  0, 1,  0, 1,\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 0, 1 ],\n",
    "   [ 1,  0, 0, 0, 1,   # { N }\n",
    "     1,  1,  0, 0, 1,\n",
    "     1,  0, 1,  0, 1,\n",
    "     1,  0, 0, 1,  1,\n",
    "     1,  0, 0, 0, 1 ],\n",
    "   [ 0, 1,  1,  1,  0,  # { O }\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 0, 1,\n",
    "     0, 1,  1,  1,  0 ],\n",
    "   [ 1,  1,  1,  1,  0,  # { P }\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  1,  1,  1,  0,\n",
    "     1,  0, 0, 0, 0,\n",
    "     1,  0, 0, 0, 0 ],\n",
    "   [ 1,  1,  1,  1,  1,   # { Q }\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 1,  1,\n",
    "     1,  1,  1,  1,  1 ],\n",
    "   [ 1,  1,  1,  1,  0,  # { R }\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  1,  1,  1,  0,\n",
    "     1,  0, 0, 1,  0,\n",
    "     1,  0, 0, 0, 1 ],\n",
    "   [ 0, 1,  1,  1,  1,   # { S }\n",
    "     1,  0, 0, 0, 0,\n",
    "     0, 1,  1,  1,  0,\n",
    "     0, 0, 0, 0, 1,\n",
    "     1,  1,  1,  1,  0 ],\n",
    "   [ 1,  1,  1,  1,  1,   # { T }\n",
    "     0, 0, 1,  0, 0,\n",
    "     0, 0, 1,  0, 0,\n",
    "     0, 0, 1,  0, 0,\n",
    "     0, 0, 1,  0, 0 ],\n",
    "   [ 1,  0, 0, 0, 1,   # { U }\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 0, 1,\n",
    "     0, 1,  1,  1,  0 ],\n",
    "   [ 1,  0, 0, 0, 1,   # { V }\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 0, 1,\n",
    "     0, 1,  0, 1,  0,\n",
    "     0, 0, 1,  0, 0 ],\n",
    "   [ 1,  0, 0, 0, 1,   # { W }\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 0, 0, 1,\n",
    "     1,  0, 1,  0, 1,\n",
    "     0, 1,  0, 1,  0 ],\n",
    "   [ 1,  0, 0, 0, 1,   # { X }\n",
    "     0, 1,  0, 1,  0,\n",
    "     0, 0, 1,  0, 0,\n",
    "     0, 1,  0, 1,  0,\n",
    "     1,  0, 0, 0, 1 ],\n",
    "   [ 1,  0, 0, 0, 1,   # { Y }\n",
    "     0, 1,  0, 1,  0,\n",
    "     0, 0, 1,  0, 0,\n",
    "     0, 0, 1,  0, 0,\n",
    "     0, 0, 1,  0, 0 ],\n",
    "   [ 1,  1,  1,  1,  1,   # { Z }\n",
    "     0, 0, 0, 1,  0,\n",
    "     0, 0, 1,  0, 0,\n",
    "     0, 1,  0, 0, 0,\n",
    "     1,  1,  1,  1,  1]  ]\n",
    "\n",
    "\n",
    "# Apprentissage des 26 lettres de l'alphabet (mémorisation dans le réseau)\n",
    "nombre_lettres = 26  # Nombre total de lettres à apprendre (A-Z)\n",
    "compteur_apprentissage = 0  # Compteur de validation des lettres apprises\n",
    "\n",
    "while compteur_apprentissage != nombre_lettres:\n",
    "    compteur_apprentissage = 0\n",
    "    for index_lettre in range(nombre_lettres):\n",
    "        lettre_en_cours = alphabet_binaire[index_lettre]  # Lettre à apprendre (ex: A, B, etc.)\n",
    "        compteur_cellules = 0  # Compteur de validation des cellules\n",
    "\n",
    "        while compteur_cellules != 25:  # Répéter jusqu'à ce que toutes les cellules de la lettre soient apprises\n",
    "            compteur_cellules = 0\n",
    "            compteur_apprentissage += 1  # Compteur global pour valider si toutes les lettres sont apprises\n",
    "\n",
    "            for index_cellule in range(25):  # Pour chaque cellule de la lettre\n",
    "                cellule_apprise = False\n",
    "                while not cellule_apprise:\n",
    "                    somme_ponderee = 0  # Calcul de la somme pondérée des entrées\n",
    "                    compteur_cellules += 1\n",
    "\n",
    "                    # Calcul de la somme pondérée des connexions pour la cellule index_cellule\n",
    "                    for i in range(25):\n",
    "                        somme_ponderee += poids_connexions[index_cellule][i] * lettre_en_cours[i]\n",
    "\n",
    "                    somme_ponderee -= seuils_cellules[index_cellule]  # Soustraction du seuil\n",
    "                    activation_fonction(somme_ponderee)  # Application de la fonction d'activation\n",
    "\n",
    "                    # Si la cellule correspond à l'état désiré pour la lettre en cours\n",
    "                    if activation_fonction(somme_ponderee) == alphabet_binaire[index_lettre][index_cellule]:\n",
    "                        cellule_apprise = True  # Sortie de la boucle, la cellule est apprise\n",
    "                    else:\n",
    "                        # Si la cellule n'a pas atteint l'état désiré, ajustement des poids et seuils\n",
    "                        erreur = abs(somme_ponderee)  # Calcul de l'erreur\n",
    "                        cellules_actives = lettre_en_cours.count(1)  # Nombre de cellules activées (valant 1)\n",
    "                        delta = (taux_apprentissage + erreur) / cellules_actives  # Calcul de la modification des poids\n",
    "\n",
    "                        # Ajustement des poids et seuils selon l'état de la cellule\n",
    "                        if lettre_en_cours[index_cellule] == 0:\n",
    "                            for i in range(25):\n",
    "                                if lettre_en_cours[i] == 1:\n",
    "                                    poids_connexions[index_cellule][i] -= delta\n",
    "                                    poids_connexions[i][index_cellule] = poids_connexions[index_cellule][i]  # Symétrie\n",
    "                            seuils_cellules[index_cellule] += delta  # Ajustement du seuil\n",
    "                        else:\n",
    "                            for i in range(25):\n",
    "                                if lettre_en_cours[i] == 1:\n",
    "                                    poids_connexions[index_cellule][i] += delta\n",
    "                                    poids_connexions[i][index_cellule] = poids_connexions[index_cellule][i]  # Symétrie\n",
    "                            seuils_cellules[index_cellule] -= delta  # Ajustement du seuil\n",
    "\n",
    "# Test de reconnaissance de la lettre bruitée (lettre_bruitee)\n",
    "historique_configurations = []  # Liste pour stocker les configurations testées\n",
    "configuration_actuelle = lettre_bruitee  # Lettre bruitée à reconnaître\n",
    "print(\"Configuration initiale de la lettre N bruitée:\", lettre_bruitee)\n",
    "test = 0  # Condition de fin de la boucle de test\n",
    "\n",
    "while test == 0:\n",
    "    for index_cellule in range(25):  # Pour chaque cellule\n",
    "        somme_ponderee = 0  # Réinitialisation de la somme pondérée\n",
    "\n",
    "        # Calcul de la somme pondérée des connexions\n",
    "        for i in range(25):\n",
    "            somme_ponderee += poids_connexions[index_cellule][i] * configuration_actuelle[i]\n",
    "\n",
    "        somme_ponderee -= seuils_cellules[index_cellule]  # Soustraction du seuil\n",
    "        configuration_actuelle[index_cellule] = activation_fonction(somme_ponderee)  # Activation\n",
    "\n",
    "    # Si la configuration est déjà présente dans la liste (convergence), fin du test\n",
    "    if configuration_actuelle in historique_configurations:\n",
    "        test = 1\n",
    "\n",
    "    # Ajout de la configuration actuelle à l'historique\n",
    "    historique_configurations.append(configuration_actuelle)\n",
    "    print(\"L'état prend la valeur -->\", configuration_actuelle)\n",
    "\n",
    "# Affichage de la configuration finale et identification de la lettre\n",
    "print(\"Configuration finale de N bruitée:\", configuration_actuelle, \"ce qui correspond à la\",\n",
    "      alphabet_binaire.index(configuration_actuelle) + 1, \"ème lettre de l'alphabet\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4cf470f4-7bef-43d5-a72d-50f3b5e15c0d",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
